Vue的数据节点：
el:指定元素id
data：存储数据
methods:方法
computed：计算属性，添加函数可以直接加在元素内容中用{{方法名}}执行，数据变更时函数自动执行重新计算。(具有缓存特性可以提升性能)
watch:监听，对data里面的数据进行监控，当数据方式发生变化时触发事件。语法：与data里面的字段名对应：比如data里面有word则word(newVluae,oldValue){},有obj{words:''}则'obj.words'(newVluae,oldValue){}

1、指令
v-html   相当于innerHTML  语法：v-html=“表达式” 
v-show   控制是否隐藏      语法：v-show=“表达式”  true表示显示，false表示隐藏。应用于经常需要隐藏和显示的元素，比如鼠标悬停显示二维码。
v-if     控制是否去除内容   语法：v-show=“表达式”  true表示显示，false表示去除。应用于只需要控制一次的显示和隐藏，比如判断是否登录时的提示。
v-else   v-else if    控制是否去除内容    语法：v-else=“表达式” 、v-else if=“表达式”   表达式不符合时隐藏，符合条件时显示。类似于if else ，必须搭配v-if使用。
v-on     注册事件          语法：v-on:事件名=“表达式”  或 @:事件名=“表达式”   比如@click，可以在表达式里面直接绑定事件并传入参数，并在Vue的methods节点中声明该方法。也可在里面直接对变量值进行更改。
v-bind   动态设置标签属性   语法：v-bind:标签=“表达式”  或 :标签=“表达式”  比如img中 :src="url" 、 :title="msg" ，url和msg可以动态设置data节点下的数据。
v-for    动态循环添加数据   语法：v-for="(item,index) in data" :key="item.id"   比如在ul li中的li添加此指令，动态添加data数组里面的数据。 key的作用相当于给id赋索引，便于Vue正确排序使用。
v-model  双向数据绑定       语法：v-model=“表达式”   绑定Vue的data节点下的数据，视图元素或data任意一方数据改变都会改变另一边。适用于登录取值请求。

2、指令修饰符
@keyup   键盘监听         语法：@keyup=“表达式”  比如@keyup.enter=“表达式”是回车键触发事件,如果只是@keyup=“表达式”则所有键盘按键都会触发
v-model.trim  v-model.number    语法：v-model=“表达式”  .trim代表用户输入文本时去除手尾空字符存入data下的字节。.number是将用户输入的文本转成数字存入，如果是字符串则已字符串存入。
@click.stop  阻止事件冒泡  @:事件名.sotp=“表达式”   相当于在触发的方法中加入e.stopPropagation()，阻止触发子容器事件的同时触发父容器的事件。
@click.prevent  阻止默认行为  语法：@click.prevent   比如在a标签中加入此指令，a标签点击时则无法进行跳转。
:class   对样式类控制进行加减  语法：:class="{类名1：布尔值，类名2：布尔值}" 或 :class="[类名1，类名2]"  可以控制某个类的样式，可以应用于菜单点击或悬浮后的样式。
:style   对单个样式进行加减    语法：:style="{样式名1：值，样式名2：值}"  比如 :style="{width：'400px'，height：'400px','background-color': 'gree'}",可以用于进度条样式。

filter：this.list=this.list.filter(item=>item.id!==传入的条件id)   在集合中的索引id找到不属于传入的条件id的集合重新赋值给list。
unshift：this.list.unshift({id:+new Date(),name=text})   在集合最前面添加数据,+new Date()是随机的时间戳
reduce：let total=this.list.reduce((sum,item)=>sum+item.num,0)  计算求和函数reduce，0代表初始值与后面的sum对应，item代表数据集合，item.num代表计算该集合中的num，相当于累加。
find：this.list.find(item=>item.id===value); 集合中找到符合条件的项进行操作
every:this.list.every(item=>item.isCheck); 指定集合中数据全部符合条件时返回true，否则返回false。
forEach：this.list.forEach(item=>item.isCheck=value); 对集合进行循环遍历并进行操作。
map：this.list.map(item => ({ value: item.price, name: item.name}));对集合数据进行遍历并返回一个新的集合
 
Vue生命周期：
1、创建阶段  响应式数据：beforeCreate   created(发送渲染请求)
2、挂载阶段  渲染模板：beforeMount   mounted(操作dom)
3、更新阶段  修改数据，更新视图：beforeUpdate   updated 
4、销毁阶段  销毁实例：beforeDestroy(释放Vue外的资源，清除定时器、延时器等)    destroyed

工程化开发 & 脚手架 Vue CLI
基本介绍:Vue CLI是 Vue 官方提供的一个全局命令工具可以帮助我们快速创建一个开发 Vue 项目的标准化基础架子。[集成了 webpack 配置]
好处:
    1.开箱即用，零配置
    2.内置babel等工具
    3.标准化
安装步骤：
    1.全局安装(一次): yarn global add @vue/cli 或 npm i @vue/cli -g （npm建议先切换淘宝镜像地址后进行安装）
        如果出现未对文件进行数字签名可以运行命令：Set-ExecutionPolicy RemoteSigned  回车后输入Y或A回车即可解决
    2.查看 Vue 版本: vue --version
    3.创建项目架子: vue create project-name (项目名-不能用中文)
    4.启动项目服务: yarn serve 或 npm run serve (找package.json中的scripts节点下的serve,serve如果更改就需要更改命令中的名称)  注意：先cd到项目目录中再执行
安装完成后可以安装一下 Vetur 插件方便编写和查看代码

(1)组件化:
页面可拆分成一个个组件，每个组件有着独立的结构、样式、行为
    好处:便于维护，利于复用 提升开发效率
    组件分类:普通组件、根组件
(2)根组件：
整个应用最上层的组件，包裹所有普通小组件。一个根组件App.vue，包含的三个部分
    template 结构(只能有一个根节点)
    style 样式(可以支持less，需要装包 less 和 less-loader )
    script 行为

普通组件使用时直接当成HTML标签使用，注册：
组件注册的两种方式:
1.局部注册:只能在注册的组件内使用
    创建vue 文件(三个组成部分:结构、样式、脚本)
    在使用的组件内导入并注册   import 组件对象 from '.vue文件路径'  export default{ components:{ 组件对象 } }
2.全局注册:所有组件内都能使用
    创建vue 文件(三个组成部分:结构、样式、脚本)
    main.js 中进行全局注册  import 组件对象 from '.vue文件路径'  Vue.component('组件名'， 组件对象 )
一般都用局部注册，如果发现确实是通用组件，再抽离到全局。

组件的三大组成部分：
1、结构（template）：根节点只能有一个
2、样式（style）：全局样式(默认):影响所有组件局部样式。加上 scoped 属性，只作用于当前组件: <style scoped></style>
3、逻辑（script）：el根实例独有,data 是一个函数其他配置项一致

组件里面的data：
一个组件的 data 选项必须是一个函数。保证每个组件实例，维护独立的一份数据对象每次创建新的组件实例，都会新执行一次 data 函数，得到一个新对象。
 data () { return { count: 100,name:'测试',... } }

  组件通信：
 组件分为父子关系和非父子关系。不同关系通讯方案不同。
 父子关系通讯方案： props 和 $emit 
    1、props : 父传子:父组件中的子组件标签添加 :title="myTitle"  子组件内部中添加 props:['title'] ，子组件就可以通过使用 title 来获取父组件中的 myTitle
        props校验：一般未做数据校验时如果传值类型不符，控制台是不会报错的。所以可以在传值过程中在子组件改成对象写法添加校验，设置类型可以是任意类型或者函数。 
            简单写法：props: { w: Number, } Number是限制只能传数字类型，否则控制台报错
            复杂写法：type：传值类型 required：是否必填  default 默认值  validator：自定义校验，返回true通过，反之控制台抛出异常
                w: { type: Number, required: true, default: 0, validator(val) { if (val > 100 || val < 0) { console.error('传入的范围必须是0-100之间') return false } else { return true } }
    }
    2、子传父（$emit）： 子组件绑定事件在事件中写入 this.$emit('changTitle','修改值')  父组件中子组件标签中添加 @changTitle="handleChange" 。handleChange是一个方法，在父组件方法中写入 
    handleChange(newTitle) { this.myTitle = newTitle }  newTitle就是子组件触发事件时传入父组件的值
    注意：子组件需要修改父组件提供的props里面的值是不可以直接修改的，必须遵循单向数据流原则，谁的数据谁负责修改。虽然不能直接修改，但是可以通过 $emit 触发父组件方法，通知父组件自己去修改 
 非父子关系通讯方案： provide&inject 和 event bus（事件总线）
    event bus（事件总线）：只适用于简单场景，复杂场景推荐使用Vuex。
        1、新建一个公共js文件，让需要通信的组件都能访问到，写入  import Vue from 'vue'; const Bus = new Vue(); export default Bus;  
        2、发送方和接收方同时引入  import Bus from '公共js文件地址' ，发送方在方法里面写入触发代码： Bus.$emit('sendMsg', '发送内容')
        3、接受方在created()里面添加监听Bus实例的事件： created() { Bus.$on('sendMsg', (msg) => { console.log(msg) }) }
    provide & inject（跨层级共享数据）：在顶层定义 provide 提供数据，在 下层定义 inject 接收数据。
        顶层： provide() { return { color: this.color,// 简单类型 是非响应式的  userInfo: this.userInfo,// 复杂类型 是响应式的 } }
        下层： inject: ['color', 'userInfo'],
 通用解决方案：Vuex(适合复杂业务场景)

v-model详解：
v-model本质上是一个语法糖。例如应用在输入框上，就是 value属性和input事件的合写。列如：v-model="msg1" 等价于 :value="msg1" @input="msg1 = $event.target.value"。
表单组件封装实现父子组件数据双向绑定，由于v-model有双向绑定的特性，恰巧父子组件不能直接修改相互之间的数据。所以需要使用上述示例的方法进行父子组件的双向数据绑定。详情参考 ./练习案例/父子组件数据双向绑定之下拉框

.sync修饰符:
作用:可以实现 子组件 与组件数据的 双向绑定，简化代码
特点: prop属性名，可以自定义，非固定为 value
场景:封装弹框类的基础组件， visible属性 true显示 false隐藏
本质:就是 :属性名 和 @update:属性名 合写  例如：:isShow.sync="isShow"  => :isShow="isShow" @update:isShow="isShow=$event"

ref 和 $refs：
作用:利用 ref 和$refs 可以用于 获取 dom 元素,或组件实例。特点: 查找范围 > 当前组件内(更精确稳定)
获取dom：1、目标标签添加 ref="属性名" 属性。2、在mounted之后通过 this.$refs.属性名 获取目标标签。也可通过该方式调用组件对象里面的方法，甚至可以直接获取方法返回的数据。

Vue异步更新、$nextTick：
Vue是异步更新 DOM 的,想要在 DOM 更新完成之后做某件事，可以使用 $nextTick
this.$nextTick(()=>{ 你需要操作的代码 })

自定义指令（自己定义的指令，可以封装一些 dom 操作，扩展额外功能）：
局部注册（directives：局部注册指令，focus：指令名：指令的配置项，在指令所在的元素，inserted：被插入到页面中时触发，update：值更新后触发，el：指令所绑定的元素，binding.value：指令绑定的值）：
    在组件中写入（此处注册了一个v-color的局部指令，用于绑定元素的颜色。相关案例参考 ./练习案例/自定义指令之v-loading）：
        directives: { color: { inserted (el,binding) { el.style.color = binding.value},update (el,binding) { el.style.color = binding.value } } } 
全局注册（Vue.directive：全局注册指令，focus：指令名：指令的配置项，在指令所在的元素，inserted：被插入到页面中时触发）：
    在main.js中写入：Vue.directive('focus', { inserted (el,binding) { el.focus() } })  //此处注册了一个v-focus的全局指令，用于给元素获取焦点。

slot 插槽（让组件内部的一些结构支持自定义）：
1.组件内需要定制的结构部分，改用<slot></slot>占位。（当父组件未提供内容时，则是空白。也可以在slot标签里面写入默认内容。例如：<slot>我是默认内容</slot>）
2.使用组件时,<MyDialog></MyDialog>标签内部,传入结构替换slot。（例如：<MyDialog><p>我是传入的内容</p></MyDialog>）
v-slot（具名插槽）：
    一旦组件的 slot 分发了name属性就属于具名插槽，只支持定向分发。需要在父组件调用时通过template标签包裹需要分发的结构，包成一个整体。
         父组件写入该组件时往里面写入：<template v-slot:插槽名称><div>我是大标题</div></template>  //v-slot:插槽名称 也可以简写成 #插槽名称
作用域插槽（可以给插槽上绑定数据，供将来使用组件时使用。例如table的内容展示、新增、修改、删除等）：
1、给slot标签以添加属性的方式传值
2、所有添加的属性，都会被收集到一个对象中
3、在template中，通过 #插槽名="obj" 接收，默认插槽名为 default

路由:
Vue中路由:路径 和 组件 的映射关系
VueRouter 的介绍：
目标:认识插件VueRouter，掌握VueRouter的基本使用。步骤作用:修改地址栏路径时，切换显示匹配的。组件说明:Vue 官方的一个路由插件，是一个第三方包
路由的使用步骤 5 + 2
5个基础步骤
    1. npm i vue-router@3.6.5      2. 引入     3. 安装注册 Vue.use(Vue插件)    4. 创建路由对象     5. 注入到new Vue中，建立关联
2个核心步骤
    1. 建组件(views目录)，配规则    2. 准备导航链接，配置路由出口(匹配的组件展示的位置) 
实现代码：
    index.js中注入： import Find from '@/views/Find'    import My from '@/views/My'     import Friend from '@/views/Friend'
                    import Vue from 'vue'
                    import VueRouter from 'vue-router'
                    Vue.use(VueRouter) // VueRouter插件初始化
                    const router = new VueRouter({ routes: [ { path: '/find', component: Find }, { path: '/my', component: My }, { path: '/friend', component: Friend }, ] })
                    export default router
    main.js中注入：  import router from './router/index'
                    new Vue({ render: h => h(App), router }).$mount('#app')
    app.vue中写入：  <router-link to="/find">发现音乐</router-link><router-link to="/my">我的音乐</router-link><router-link to="/friend">朋友</router-link> 
                    <!-- 路由出口 → 匹配的组件所展示的位置,可以写在某个盒子中 --> <router-view></router-view>
声明式导航：
实现导航高亮:vue-router 提供了一个全局组件 router-link(取代a标签)
    1、能跳转，配置to届性指定路径(必须)。本质还是a标签，to 无需# 
    2、能高亮，默认就会提供高亮类名(.router-link-active(模糊匹配，用的更多),.router-link-exact-active(精确匹配))，可以直接设置高亮样式
跳转传参：
    1.查询参数传参(适合多个参数，用&隔开)
        1、语法格式如下 to="/path?参数名=值 2、对应页面组件接收传递过来的值 $route.query.参数名  在created()中需要在最前方加上this
    2.动态路由传参(适合单个参数，比较简洁。/find/:words?如果没有加?，那么这个参数是必传的，如果不传就无法匹配路由)
        1、配置动态路由 path: '/find/:words?' 2、配置导航链接 to="/path/参数值" 3、对应页面组件传递过来的值 $route.params.words 在created()中需要在最前方加上this
自定义高亮类名（ 在实例化时(const router = new VueRouter)加入代码,与routes同级）：
    linkActiveClass: 'active', // 配置模糊匹配的类名
    linkExactActiveClass: 'exact-active' // 配置精确匹配的类名
路由重定向： 在实例路由集合最前加上：{ path: '/', redirect: '/home' }//默认跳转到home
路由-404（当路径找不到匹配时，给个提示页面）：在实例路由集合最后加上：{ path: '*', component: NotFound } //新建NotFound.vue，前面所有路由都没有找到则跳转到NotFound.vue
路由模式设置(默认mode:"hash",地址栏去除#,改成history)：在实例化时(const router = new VueRouter)加入代码 mode:"history" ,与routes同级、
编程式导航（js形式）：
1、path路径跳转：this.$router.push({ path: '路径' })
    传参：1、地址传参同上。 2、this.$router.push({ path: '路径',query:{ key:this.inputVal,value:this.inputVal } })
2、路由名称跳转(适合路径名称长的场景)：this.$router.push({ name: '路由名称' }) //需要在实例化路由集合中给每个路由定义name属性和对应名称
    传参：1、this.$router.push({ name: '路由名称',query:{ key:this.inputVal } })    2、动态路由：this.$router.push({ name: '路由名称',params:{ words:this.inputVal } })
组件缓存 keep-alive
1.keep-alive是什么
    keep-alive是Vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们
    keep-alive 是一个抽象组件: 它自身不会染成一个 DOM 元素，也不会出现在父组件链中。
2.keep-alive的优点
    在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM减少加载时间及性能消耗，提高用户体验性。
3.keep-alive的三个属性
    include :组件名数组，只有匹配的组件会被缓存
@exclude:组件名数组，任何匹配的组件都不会被缓存
最多可以缓存多少组件实例
Bmax